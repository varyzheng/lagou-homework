## 一.解释执行结果
```js
var a = [];
for (var i = 0; i < 10; i += 1) {
  a[i] = function(){
    console.log(i);
  }
}
a[6](); // 10
```
因为在`for`循环体中，`i`使用`var`声明会存在变量提升，`i`被定义到了全局，循环执行结束后，`i`的值为`10`，函数内部的`i`会沿着作用域链向上找到全局的`i`，即为`10`。

## 二.解释执行结果
```js
var tmp = 123
if (true) {
  console.log(tmp)  // Uncaught ReferenceError: Cannot access 'tmp' before initialization
  let tmp
}
```
代码会报错，因为在`if`的代码块中，使用了`let`关键字定义`tmp`变量，因此在这个代码块中，`let tmp`之前的区域，是`tmp`变量的`TDZ(temporal dead zone:暂时性死区)`，在`TDZ`中使用未定义的变量会报错。

## 三.使用ES6语法找数组中最小值
```js
var arr = [12, 34, 32, 89, 4];
console.log(Math.min(...arr));
```

## 四.var, let, const声明变量的区别
`var`区别于`let`和`const`的点在于：  
  1. `var`存在变量提升，定义的变量相当于会在当前的代码执行栈最上方添加了一个`var xxx = undefined;`
  2. 因为存在变量提升，所以在声明语句之前使用`xxx`的值，也是被允许的，它的值是`undefined`，而且`var`声明的变量不受大括号限制，在括号之外也可以正常访问到
  3. 在全局使用`var`声明的变量，会被挂载到全局对象中,  如：
  ```js
  var globalValue = 123;
  console.log(window.globalValue) // 123
  ```
  以上三点特性，`let`和`const`都不支持。`let`和`const`声明变量，只在当前代码块(大括号)内生效，而且必须在声明语句之后使用，因为一旦使用`let`或`const`声明变量，声明语句之前的部分会成为该变量的`TDZ(temporal dead zone:暂时性死区)`，在`TDZ`中使用未定义的变量会报错。

  `let` 和 `const`的区别是，使用`let`声明的变量允许重新赋值（修改变量的引用），使其指向其他内存地址。但`const`声明的变量不允许重新赋值，即变量与某内存地址绑定，但是可以修改该内存地址内的内容。

  ## 五.解释执行结果
```js
var a = 10;
var obj = {
  a: 20,
  fn() {
    setTimeout(() => {
      console.log(this.a)
    })
  }
}
obj.fn(); // 20
```
定时器内输出的`this.a`，因为使用箭头函数作为定时器的回调，因此`this`的指向与箭头函数声明时的`this`指向一致，即`fn`调用时的`this`，`fn`的调用由`obj`发起，因此`fn`的`this`指向`obj`，因此`this.a === obj.a`，结果为20

## 六.Symbol类型的用途
1. 私有化属性
2. 提供唯一的key值
3. 代替枚举类型的值

## 七.什么是浅拷贝，什么事深拷贝
浅拷贝是指引用的复制，两个引用指向的是同一块内存地址，通过任何一个引用修改其值，另一个引用所引用的对象值也跟着变化。如：
```js
var a = {}
var b = a
b.name = 'zhangsan'
console.log(a.name) // zhangsan
```
而深拷贝则真实的开辟了另一份内存空间，两个引用分别指向两块不同内存地址。如
```js
var a = { name: 'zhangsan' }
var b = { ...a }
b.name = 'lisi'
console.log(a.name) // zhangsan
```

## 八. TypeScript和JavaScript之间的关系
JavaScript 的超集，可以在TypeScript中直接编写JavaScript，具有JavaScript的全部功能。在此基础上，实现了类型声明，接口，泛型等其他高级编程语言的特性。TypeScript会在执行前编译为JavaScript运行。

## 九.TypeScript 的优缺点
优点是提供了更高级的编程语言的特性，使用类型检查，可以在编码阶段提前发现可能发生的错误，并且拥有更智能的代码提示，在修改代码时，能自动识别出不支持的地方，避免人工查找，省时又能避免遗漏。

缺点是不仅需要为某一数据类型定义相关的接口或者类，而且有一些资源库的`@type`包与项目引用的版本不一致，需要单独维护。

## 十.引用计数的工作原理和优缺点
为每一个引用做一个计数器，每有一个地方引用到了，就会 + 1，当引用清空就会 - 1，如果引用计数变成0意味着再也无法通过代码获得这块内存地址，即会被释放

优点是：实时性，一旦没有引用，内存就直接释放了。
缺点是：维护引用计数消耗资源，而且无法处理循环引用的问题。

## 十一. 标记整理算法的工作流程
第一步与标记清除算法相同，先从根节点开始向下查询，所有能访问到的元素都会打上一个标记，第二步是对没有标记的引用进行内存释放，第三步是对有标记的元素进行整理，放到连续的内存地址当中，解决内存碎片过多造成的内存浪费。

## 十二. V8中新生代存储区垃圾回收的流程
先对新生代存储区进行分割，分成大小相等两份空间，记为`From`和`To`，`From`中存放当前所有活动对象，`To`中是空白区域。当触发GC时，将`From`中可以由根节点访问到的活动对象复制到`To`区域，复制完成后将`From`的全部活动对象释放，然后进行`From`和`To`的交换。因为在复制过程中，内存分配是连续的，所以无需进行整理算法，也能保证内存碎片。

在从`From`复制到`To`的过程中，可能会有对象晋升（复制到老生代区）的情况出现，出现的条件有两种：
1. 活动对象已经经历过一次GC，那么会被认为此对象有可能被长期引用，所以被复制到老生代区
2. `To`区的内存空间占用超过`25%`

## 十三. 增量标记算法在何时使用及工作原理

增量标记算法被V8引擎引用，在老生代存储区的垃圾回收时使用。
增量标记的工作原理是，把原本标记清除算法或者标记整理算法的标记过程拆分成多个步骤来完成，每个步骤与JS代码的执行穿插进行，这样保证了JS的正常工作，用户不会觉得突然的卡顿，也保证了正常的垃圾回收顺利进行。
